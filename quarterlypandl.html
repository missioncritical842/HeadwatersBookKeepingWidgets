<!-- Profit and Loss Statement Widget with Detailed Account Breakdown and Totals -->
<!-- API-enabled Version: Accesses 'Bank_Transactions' table directly -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Profit and Loss Statement Widget</title>
  
  <!-- External Script -->
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  
  <!-- Styling for better appearance -->
  <style>
    /* Container Styling */
    #pl-statement {
      font-family: Georgia, serif; /* Changed to a serif font */
      margin: 20px;
      font-size: 14px; /* Base font size reduced */
      color: #333; /* Dark grey text for better readability */
    }
    /* Main Heading Styling */
    #pl-statement h2 {
      text-align: center; /* Center the heading */
      margin-bottom: 20px;
      line-height: 1.2; /* Adjust line height for better spacing between lines */
      font-size: 20px; /* Reduced font size */
    }
    /* Span Styling for Heading Lines */
    #pl-statement h2 .line1 {
      display: block; /* Ensure each span starts on a new line */
      font-size: 20px; /* Reduced font size */
      font-weight: bold;
    }
    #pl-statement h2 .line2 {
      display: block; /* Ensure each span starts on a new line */
      font-size: 16px; /* Reduced font size */
      font-weight: normal;
      color: #555; /* Different color for the second line */
    }
    /* New Line Styling for Month Subtitle */
    #pl-statement h2 .line3 {
      display: block;
      font-size: 16px;
      font-weight: normal;
      color: #555; /* Similar to line2 */
    }
    /* Detailed sections styling */
    .details-section {
      margin-bottom: 40px;
    }
    .details-section h3 {
      margin-bottom: 10px;
      font-size: 16px; /* Reduced font size */
      font-weight: bold;
      color: #444; /* Slightly lighter grey for subheadings */
    }
    .details-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
      font-size: 14px; /* Consistent with base font size */
    }
    .details-table th, .details-table td {
      border: 1px solid #ccc;
      padding: 6px; /* Reduced padding for compactness */
      vertical-align: middle; /* Align text vertically center */
    }
    .details-table th {
      background-color: #e6e6e6;
      text-align: left;
      font-size: 14px; /* Consistent font size */
    }
    .details-table td {
      text-align: right;
      font-size: 14px; /* Consistent font size */
    }
    .details-table td:first-child {
      text-align: left;
    }
    /* Totals row styling */
    .details-table .total-row {
      font-weight: bold;
      background-color: #f9f9f9;
      font-size: 14px; /* Consistent font size */
    }
    /* Negative amount styling */
    .negative-amount {
      color: red;
    }
    /* Net Profit styling */
    #net-profit-section {
      font-size: 16px; /* Reduced font size */
      font-weight: bold;
      text-align: center; /* Center the Net Profit display */
      margin-top: 20px;
      color: #333; /* Ensure visibility */
    }
    /* Error message styling */
    #error-message {
      color: red;
      font-weight: bold;
      margin-top: 10px;
      text-align: center; /* Center the error message */
      font-size: 14px; /* Consistent font size */
    }
    /* Styles for additional text input */
    #additional-text-container {
      margin-top: 10px;
      margin-bottom: 20px;
      text-align: center; /* Center the input container */
    }
    #additionalTextInput {
      width: 80%;
      max-width: 400px; /* Optional: Maximum width for larger screens */
      padding: 6px; /* Reduced padding */
      font-size: 14px; /* Consistent font size */
      border: none; /* Removed the border */
      border-radius: 4px;
      background-color: #f0f0f0; /* Light background for visibility */
      outline: none; /* Remove default outline */
      text-align: center; /* Center the input text */
      transition: box-shadow 0.3s ease, background-color 0.3s ease; /* Smooth transitions for focus effect */
      font-family: inherit; /* Inherit the serif font */
    }
    #additionalTextInput:focus {
      box-shadow: 0 0 5px rgba(81, 203, 238, 1); /* Adds a subtle blue glow on focus */
      background-color: #fff; /* Change background on focus */
    }
    /* Hidden text content for printing */
    #additionalTextContent {
      display: none;
    }
    /* Indentation Classes */
    .indent-1 {
      padding-left: 20px; /* First level of indentation */
    }
    .indent-2 {
      padding-left: 40px; /* Second level of indentation */
    }
    .indent-3 {
      padding-left: 60px; /* Third level of indentation */
    }
    .indent-4 {
      padding-left: 80px; /* Fourth level of indentation */
    }
    /* Responsive Design */
    @media (max-width: 600px) {
      .details-table {
        width: 100%;
      }
      #additionalTextInput {
        width: 100%;
      }
    }
    /* Printing Styles */
    @media print {
      #additionalTextInput {
        display: none;
      }
      #additionalTextContent {
        display: none;
      }
      #additionalTextContent.hasContent {
        display: block;
        text-align: center;
        font-size: 14px;
        margin-top: 10px;
        margin-bottom: 20px;
        font-family: inherit; /* Ensure consistent font */
      }
    }
  </style>
</head>
<body>
  <div id="pl-statement">
    <!-- Main Heading Split into Two Lines -->
    <h2>
      <span class="line1">Headwaters Christian Resources</span>
      <span class="line2">Profit and Loss Statement (API View)</span>
      <span class="line3" id="monthSubtitle"></span>
    </h2>
    
    <!-- Additional Text Input Container -->
    <div id="additional-text-container">
      <input type="text" id="additionalTextInput" placeholder="Enter additional text here" />
      <div id="additionalTextContent"></div>
    </div>
    
    <!-- Detailed Income Accounts -->
    <div class="details-section">
      <h3>Income</h3>
      <table class="details-table" id="income-details">
        <tr>
          <th>Account</th>
          <th>Amount</th>
        </tr>
      </table>
    </div>
    
    <!-- Detailed Expense Accounts -->
    <div class="details-section">
      <h3>Expense</h3>
      <table class="details-table" id="expense-details">
        <tr>
          <th>Account</th>
          <th>Amount</th>
        </tr>
      </table>
    </div>
    
    <!-- Net Profit Display -->
    <div id="net-profit-section">
      Net Profit: <span id="net-profit">$0.00</span>
    </div>
    
    <!-- Error Message -->
    <div id="error-message"></div>
  </div>
  
  <!-- JavaScript Section -->
  <script>
    // --- Constants ---
    // The name of the table containing transactions.
    // Ensure this matches your Grist table name EXACTLY.
    const TRANSACTIONS_TABLE = "Bank_Transactions";

    // Expected column names in Bank_Transactions
    const COL_AMOUNT = "Amount";
    const COL_DATE = "Transaction_Date";
    const COL_TYPE = "Account_Type_Name";
    // Hierarchy columns (assumed to be available in Bank_Transactions, e.g. via formulas)
    const COL_ACC_1 = "Accounts_1";
    const COL_ACC_2 = "Accounts_2";
    const COL_ACC_3 = "Accounts_3";
    const COL_ACC_4 = "Accounts_4";

    // Function to handle additional text input
    function handleAdditionalText() {
      const input = document.getElementById('additionalTextInput').value.trim();
      const additionalTextContent = document.getElementById('additionalTextContent');
      additionalTextContent.textContent = input;
      if (input) {
        additionalTextContent.classList.add('hasContent');
      } else {
        additionalTextContent.classList.remove('hasContent');
      }
    }
    
    document.addEventListener('DOMContentLoaded', function() {
      const additionalTextInput = document.getElementById('additionalTextInput');
      if (additionalTextInput) {
        additionalTextInput.addEventListener('input', handleAdditionalText);
      }
    });

    // Initialize Grist with full access to fetch tables
    // Changed to 'read table' as 'full' might be blocked by permissions
    grist.ready({
      columns: [],
      requiredAccess: 'read table'
    });

    // Function to build hierarchical account structure
    function buildHierarchy(records, accountType) {
      const hierarchy = {};
      records.forEach(record => {
        // Safe access to fields (handle if they are missing/undefined)
        const type = record[COL_TYPE];
        if (type && String(type).trim().toLowerCase() === accountType.toLowerCase()) {
          const amount = parseFloat(record[COL_AMOUNT]) || 0;
          const accounts1 = record[COL_ACC_1] || 'Uncategorized';
          const accounts2 = record[COL_ACC_2] || '';
          const accounts3 = record[COL_ACC_3] || '';
          const accounts4 = record[COL_ACC_4] || '';
          
          if (!hierarchy[accounts1]) {
            hierarchy[accounts1] = { amount: 0, children: {} };
          }
          hierarchy[accounts1].amount += amount;
          
          if (accounts2) {
            if (!hierarchy[accounts1].children[accounts2]) {
              hierarchy[accounts1].children[accounts2] = { amount: 0, children: {} };
            }
            hierarchy[accounts1].children[accounts2].amount += amount;
            
            if (accounts3) {
              if (!hierarchy[accounts1].children[accounts2].children[accounts3]) {
                hierarchy[accounts1].children[accounts2].children[accounts3] = { amount: 0, children: {} };
              }
              hierarchy[accounts1].children[accounts2].children[accounts3].amount += amount;
              
              if (accounts4) {
                if (!hierarchy[accounts1].children[accounts2].children[accounts3].children[accounts4]) {
                  hierarchy[accounts1].children[accounts2].children[accounts3].children[accounts4] = { amount: 0 };
                }
                hierarchy[accounts1].children[accounts2].children[accounts3].children[accounts4].amount += amount;
              }
            }
          }
        }
      });
      return hierarchy;
    }

    function sortHierarchy(hierarchy) {
      const sorted = {};
      const keys = Object.keys(hierarchy).sort((a, b) => a.localeCompare(b));
      keys.forEach(key => {
        sorted[key] = { ...hierarchy[key] };
        if (sorted[key].children && Object.keys(sorted[key].children).length > 0) {
          sorted[key].children = sortHierarchy(sorted[key].children);
        }
      });
      return sorted;
    }

    function insertHierarchyIntoTable(hierarchy, tableBody, level = 0) {
      const indentClass = `indent-${level}`;
      Object.keys(hierarchy).forEach(account => {
        const row = tableBody.insertRow();
        const accountCell = row.insertCell(0);
        const amountCell = row.insertCell(1);
        accountCell.innerHTML = `<span class="${indentClass}">${account}</span>`;
        amountCell.innerText = `$${hierarchy[account].amount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
        
        if (hierarchy[account].children && Object.keys(hierarchy[account].children).length > 0) {
          insertHierarchyIntoTable(hierarchy[account].children, tableBody, Math.min(level + 1, 4));
        }
      });
    }

    async function loadData() {
      const errorMessage = document.getElementById('error-message');
      
      try {
        console.log(`Fetching table: ${TRANSACTIONS_TABLE}`);
        const data = await grist.docApi.fetchTable(TRANSACTIONS_TABLE);
        
        if (!data) {
          throw new Error(`Table '${TRANSACTIONS_TABLE}' not found or empty.`);
        }

        // Normalize records: Grist returns {id: [ids], col1: [vals], ...} or array of objects depending on version?
        // Actually grist.docApi.fetchTable returns an object with columns as keys and arrays of values, OR an array of objects?
        // Let's check docs: it typically returns a list of records: [{id: 1, fields: {...}}, ...] is NOT what fetchTable returns.
        // fetchTable returns objects: { id: [...], colA: [...], colB: [...] } (Column-oriented)
        // OR standard JSON list if using the REST API format?
        // The Plugin API documentation says fetchTable returns: { id: [1, 2], Name: ['A', 'B'] }
        
        // We need to convert this column-oriented data to row-oriented for easier processing
        const records = [];
        const ids = data.id;
        if (ids && ids.length) {
          for (let i = 0; i < ids.length; i++) {
            const record = { id: ids[i] };
            // Copy all fields
            for (const key in data) {
              if (key !== 'id') {
                record[key] = data[key][i];
              }
            }
            records.push(record);
          }
        }
        
        console.log(`Loaded ${records.length} records.`);
        processRecords(records);

      } catch (err) {
        console.error("Error loading data:", err);
        errorMessage.innerText = `Error loading data from table '${TRANSACTIONS_TABLE}'. Check console for details.`;
      }
    }

    function processRecords(records) {
      const incomeDetails = document.getElementById('income-details');
      const expenseDetails = document.getElementById('expense-details');
      const netProfitDisplay = document.getElementById('net-profit');
      const monthSubtitle = document.getElementById('monthSubtitle');
      const errorMessage = document.getElementById('error-message');

      // Reset UI
      errorMessage.innerText = '';
      incomeDetails.innerHTML = `<tr><th>Account</th><th>Amount</th></tr>`;
      expenseDetails.innerHTML = `<tr><th>Account</th><th>Amount</th></tr>`;
      netProfitDisplay.innerText = '$0.00';

      // --- QUARTERLY LOGIC ---
      const today = new Date();
      const currentMonth = today.getMonth(); // 0-11
      const currentYear = today.getFullYear();

      let previousQuarterStartMonth;
      let previousQuarterEndMonth;
      let previousQuarterYear;
      let quarterName;

      if (currentMonth >= 0 && currentMonth <= 2) { 
        // Current: Jan-Mar (Q1) -> Prev: Q4 of Prev Year
        previousQuarterStartMonth = 9; // Oct (0-indexed)
        previousQuarterEndMonth = 11; // Dec (0-indexed)
        previousQuarterYear = currentYear - 1;
        quarterName = "Q4";
      } else if (currentMonth >= 3 && currentMonth <= 5) { 
        // Current: Apr-Jun (Q2) -> Prev: Q1 of Current Year
        previousQuarterStartMonth = 0; 
        previousQuarterEndMonth = 2; 
        previousQuarterYear = currentYear;
        quarterName = "Q1";
      } else if (currentMonth >= 6 && currentMonth <= 8) { 
        // Current: Jul-Sep (Q3) -> Prev: Q2 of Current Year
        previousQuarterStartMonth = 3; 
        previousQuarterEndMonth = 5; 
        previousQuarterYear = currentYear;
        quarterName = "Q2";
      } else { 
        // Current: Oct-Dec (Q4) -> Prev: Q3 of Current Year
        previousQuarterStartMonth = 6; 
        previousQuarterEndMonth = 8; 
        previousQuarterYear = currentYear;
        quarterName = "Q3";
      }

      // Calculate Dates
      // Start Date: 1st of Start Month
      const firstDayOfPreviousQuarter = new Date(previousQuarterYear, previousQuarterStartMonth, 1);
      
      // End Date: Last day of End Month
      // Date(year, month + 1, 0) gives the last day of the 'month'
      const lastDayOfPreviousQuarter = new Date(previousQuarterYear, previousQuarterEndMonth + 1, 0); 
      
      // Extend the end date to include the full day (23:59:59.999) for comparison if date objects have time
      lastDayOfPreviousQuarter.setHours(23, 59, 59, 999);

      // Helper to format date as YYYY-MM-DD
      const formatDate = (d) => {
        return d.getFullYear() + '-' + 
               String(d.getMonth() + 1).padStart(2, '0') + '-' + 
               String(d.getDate()).padStart(2, '0');
      };

      const startStr = formatDate(firstDayOfPreviousQuarter);
      const endStr = formatDate(lastDayOfPreviousQuarter);

      // Debugging Dates
      console.log('Quarter Calculation:', {
        today: today.toISOString(),
        currentMonth,
        currentYear,
        quarterName,
        previousQuarterYear,
        start: startStr,
        end: endStr
      }); 

      const monthNames = ["January", "February", "March", "April", "May", "June",
                          "July", "August", "September", "October", "November", "December"];
      
      const startMonthName = monthNames[firstDayOfPreviousQuarter.getMonth()];
      const endMonthName = monthNames[lastDayOfPreviousQuarter.getMonth()];
      const subtitleText = `${quarterName} ${previousQuarterYear} (${startMonthName} - ${endMonthName})`;

      if (monthSubtitle) {
        monthSubtitle.textContent = subtitleText;
      }

      // Log first record keys to debug column names
      if (records.length > 0) {
        console.log("First record keys:", Object.keys(records[0]));
        console.log("First record sample:", records[0]);
      }

      // Filter Records
      const filteredRecords = records.filter(record => {
        const dateVal = record[COL_DATE];
        
        // Log if date is missing
        if (!dateVal) {
            console.warn("Record missing date:", record);
            return false;
        }
        
        // Grist often returns dates as timestamps (seconds or ms) or ISO strings
        // Try to parse
        let transactionDate;
        if (typeof dateVal === 'number') {
           // Grist dates are often seconds since epoch
           transactionDate = new Date(dateVal * 1000);
        } else {
           transactionDate = new Date(dateVal);
        }

        if (isNaN(transactionDate.getTime())) {
            console.warn("Invalid date:", dateVal);
            return false;
        }

        // Compare using YYYY-MM-DD strings to avoid timezone issues
        const txStr = formatDate(transactionDate);
        const isMatch = txStr >= startStr && txStr <= endStr;
        
        // Debug first few failures to see why they are failing
        // Only log if we haven't found a match yet and it's one of the first few
        if (!isMatch) {
            console.log("Date mismatch:", {
                val: dateVal,
                parsed: transactionDate.toISOString(),
                txStr: txStr,
                start: startStr,
                end: endStr
            });
        }
        
        return isMatch;
      });

      if (filteredRecords.length === 0) {
        errorMessage.innerText = `No transactions found for ${subtitleText}.`;
        return;
      }

      // Separate records
      const incomeRecords = [];
      const expenseRecords = [];
      
      filteredRecords.forEach(record => {
        const type = String(record[COL_TYPE] || '').trim().toLowerCase();
        if (type === 'income') {
          incomeRecords.push(record);
        } else if (type === 'expense') {
          expenseRecords.push(record);
        }
      });
      
      const hierarchyIncome = sortHierarchy(buildHierarchy(incomeRecords, 'Income'));
      const hierarchyExpense = sortHierarchy(buildHierarchy(expenseRecords, 'Expense'));
      
      insertHierarchyIntoTable(hierarchyIncome, incomeDetails);
      
      let totalIncome = 0;
      Object.values(hierarchyIncome).forEach(account => {
        totalIncome += account.amount;
      });
      
      insertHierarchyIntoTable(hierarchyExpense, expenseDetails);
      
      let totalExpenses = 0;
      Object.values(hierarchyExpense).forEach(account => {
        totalExpenses += account.amount;
      });
      
      const netProfit = totalIncome + totalExpenses; 
      
      netProfitDisplay.innerText = `$${netProfit.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
      
      const incomeTotalRow = incomeDetails.insertRow();
      incomeTotalRow.classList.add('total-row');
      const incomeTotalLabel = incomeTotalRow.insertCell(0);
      const incomeTotalAmount = incomeTotalRow.insertCell(1);
      incomeTotalLabel.innerText = 'Total Income';
      incomeTotalAmount.innerText = `$${totalIncome.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
      
      const expenseTotalRow = expenseDetails.insertRow();
      expenseTotalRow.classList.add('total-row');
      const expenseTotalLabel = expenseTotalRow.insertCell(0);
      const expenseTotalAmount = expenseTotalRow.insertCell(1);
      expenseTotalLabel.innerText = 'Total Expenses';
      expenseTotalAmount.innerText = `$${Math.abs(totalExpenses).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    }

    // Trigger data load
    loadData();
  </script>
</body>
</html>
