<!-- Profit and Loss Statement Widget with Detailed Account Breakdown and Totals -->
<!-- API-enabled Version: Accesses 'Transaction_Categorization' and related tables directly -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Profit and Loss Statement Widget (v2.2)</title>
  
  <!-- External Script -->
  <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
  
  <!-- Styling for better appearance -->
  <style>
    /* Container Styling */
    #pl-statement {
      font-family: Georgia, serif; /* Changed to a serif font */
      margin: 20px;
      font-size: 14px; /* Base font size reduced */
      color: #333; /* Dark grey text for better readability */
    }
    /* Main Heading Styling */
    #pl-statement h2 {
      text-align: center; /* Center the heading */
      margin-bottom: 20px;
      line-height: 1.2; /* Adjust line height for better spacing between lines */
      font-size: 20px; /* Reduced font size */
    }
    /* Span Styling for Heading Lines */
    #pl-statement h2 .line1 {
      display: block; /* Ensure each span starts on a new line */
      font-size: 20px; /* Reduced font size */
      font-weight: bold;
    }
    #pl-statement h2 .line2 {
      display: block; /* Ensure each span starts on a new line */
      font-size: 16px; /* Reduced font size */
      font-weight: normal;
      color: #555; /* Different color for the second line */
    }
    /* New Line Styling for Month Subtitle */
    #pl-statement h2 .line3 {
      display: block;
      font-size: 16px;
      font-weight: normal;
      color: #555; /* Similar to line2 */
    }
    /* Detailed sections styling */
    .details-section {
      margin-bottom: 40px;
    }
    .details-section h3 {
      margin-bottom: 10px;
      font-size: 16px; /* Reduced font size */
      font-weight: bold;
      color: #444; /* Slightly lighter grey for subheadings */
    }
    .details-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
      font-size: 14px; /* Consistent with base font size */
    }
    .details-table th, .details-table td {
      border: 1px solid #ccc;
      padding: 6px; /* Reduced padding for compactness */
      vertical-align: middle; /* Align text vertically center */
    }
    .details-table th {
      background-color: #e6e6e6;
      text-align: left;
      font-size: 14px; /* Consistent font size */
    }
    .details-table td {
      text-align: right;
      font-size: 14px; /* Consistent font size */
    }
    .details-table td:first-child {
      text-align: left;
    }
    /* Totals row styling */
    .details-table .total-row {
      font-weight: bold;
      background-color: #f9f9f9;
      font-size: 14px; /* Consistent font size */
    }
    /* Negative amount styling */
    .negative-amount {
      color: red;
    }
    /* Net Profit styling */
    #net-profit-section {
      font-size: 16px; /* Reduced font size */
      font-weight: bold;
      text-align: center; /* Center the Net Profit display */
      margin-top: 20px;
      color: #333; /* Ensure visibility */
    }
    /* Error message styling */
    #error-message {
      color: red;
      font-weight: bold;
      margin-top: 10px;
      text-align: center; /* Center the error message */
      font-size: 14px; /* Consistent font size */
    }
    /* Styles for additional text input */
    #additional-text-container {
      margin-top: 10px;
      margin-bottom: 20px;
      text-align: center; /* Center the input container */
    }
    #additionalTextInput {
      width: 80%;
      max-width: 400px; /* Optional: Maximum width for larger screens */
      padding: 6px; /* Reduced padding */
      font-size: 14px; /* Consistent font size */
      border: none; /* Removed the border */
      border-radius: 4px;
      background-color: #f0f0f0; /* Light background for visibility */
      outline: none; /* Remove default outline */
      text-align: center; /* Center the input text */
      transition: box-shadow 0.3s ease, background-color 0.3s ease; /* Smooth transitions for focus effect */
      font-family: inherit; /* Inherit the serif font */
    }
    #additionalTextInput:focus {
      box-shadow: 0 0 5px rgba(81, 203, 238, 1); /* Adds a subtle blue glow on focus */
      background-color: #fff; /* Change background on focus */
    }
    /* Hidden text content for printing */
    #additionalTextContent {
      display: none;
    }
    /* Indentation Classes */
    .indent-1 {
      padding-left: 20px; /* First level of indentation */
    }
    .indent-2 {
      padding-left: 40px; /* Second level of indentation */
    }
    .indent-3 {
      padding-left: 60px; /* Third level of indentation */
    }
    .indent-4 {
      padding-left: 80px; /* Fourth level of indentation */
    }
    /* Responsive Design */
    @media (max-width: 600px) {
      .details-table {
        width: 100%;
      }
      #additionalTextInput {
        width: 100%;
      }
    }
    /* Printing Styles */
    @media print {
      #additionalTextInput {
        display: none;
      }
      #additionalTextContent {
        display: none;
      }
      #additionalTextContent.hasContent {
        display: block;
        text-align: center;
        font-size: 14px;
        margin-top: 10px;
        margin-bottom: 20px;
        font-family: inherit; /* Ensure consistent font */
      }
    }
  </style>
</head>
<body>
  <div id="pl-statement">
    <!-- Main Heading Split into Two Lines -->
    <h2>
      <span class="line1">Headwaters Christian Resources</span>
      <span class="line2">Profit and Loss Statement (v2.2)</span>
      <span class="line3" id="monthSubtitle"></span>
    </h2>
    
    <!-- Additional Text Input Container -->
    <div id="additional-text-container">
      <input type="text" id="additionalTextInput" placeholder="Enter additional text here" />
      <div id="additionalTextContent"></div>
    </div>
    
    <!-- Detailed Income Accounts -->
    <div class="details-section">
      <h3>Income</h3>
      <table class="details-table" id="income-details">
        <tr>
          <th>Account</th>
          <th>Amount</th>
        </tr>
      </table>
    </div>
    
    <!-- Detailed Expense Accounts -->
    <div class="details-section">
      <h3>Expense</h3>
      <table class="details-table" id="expense-details">
        <tr>
          <th>Account</th>
          <th>Amount</th>
        </tr>
      </table>
    </div>
    
    <!-- Net Profit Display -->
    <div id="net-profit-section">
      Net Profit: <span id="net-profit">$0.00</span>
    </div>
    
    <!-- Error Message -->
    <div id="error-message"></div>
  </div>
  
  <!-- JavaScript Section -->
  <script>
    // Initialize the widget
    grist.ready({
      columns: [], // No column mapping needed
      requiredAccess: 'read table' // We need full table access
    });

    // Constants for table and column names
    const TABLE_TRANSACTIONS = "Transaction_Categorization";
    const TABLE_ACCOUNTS = "Accounts";
    const TABLE_ACCOUNT_TYPES = "Account_Types";
    const TABLE_ORG_SETTINGS = "Organization_Settings";
    
    // Column IDs for Transaction_Categorization
    const COL_TRANS_AMOUNT = "Amount";
    const COL_TRANS_DATE_CLEARED = "Date_Cleared";
    const COL_TRANS_DATE_POSTED = "Change_Date_Posted"; // Stored date override
    const COL_TRANS_ACCOUNT_REF = "Account_Long_Name"; // Ref to Accounts

    // Column IDs for Accounts
    const COL_ACC_ID = "id"; // Grist Row ID
    const COL_ACC_ACCOUNT_ID = "ACCOUNT_ID"; // User-defined ID for parenting
    const COL_ACC_NAME = "ACCOUNT_NAME";
    const COL_ACC_TYPE_REF = "ACCOUNT_TYPE"; // Ref to Account_Types
    const COL_ACC_PARENT = "PARENT_ACCOUNT"; // Refers to ACCOUNT_ID

    // Column IDs for Account_Types
    const COL_TYPE_ID = "id"; // Grist Row ID
    const COL_TYPE_NAME = "TYPE_NAME";
    const COL_ORG_NAME = "Org_Name";

    // Global variables to store data
    let transactions = [];
    let accountsMap = {}; // RowID -> Account Record
    let accountsByIdMap = {}; // ACCOUNT_ID -> Account Record
    let accountTypesMap = {}; // RowID -> Type Name

    // Function to handle additional text input
    function handleAdditionalText() {
      const input = document.getElementById('additionalTextInput').value.trim();
      const additionalTextContent = document.getElementById('additionalTextContent');
      additionalTextContent.textContent = input;
      if (input) {
        additionalTextContent.classList.add('hasContent');
      } else {
        additionalTextContent.classList.remove('hasContent');
      }
    }
    
    document.addEventListener('DOMContentLoaded', function() {
      const additionalTextInput = document.getElementById('additionalTextInput');
      if (additionalTextInput) {
        additionalTextInput.addEventListener('input', handleAdditionalText);
      }
    });

    // Function to load data from all required tables
    async function loadData() {
      const errorMessage = document.getElementById('error-message');
      try {
        console.log("Fetching tables...");
        const [transData, accData, typeData, orgData] = await Promise.all([
          grist.docApi.fetchTable(TABLE_TRANSACTIONS),
          grist.docApi.fetchTable(TABLE_ACCOUNTS),
          grist.docApi.fetchTable(TABLE_ACCOUNT_TYPES),
          grist.docApi.fetchTable(TABLE_ORG_SETTINGS)
        ]);

        console.log("Tables fetched. Processing...");

        
        const orgRecords = convertToRecords(orgData);
        const orgName = (orgRecords.length > 0 && orgRecords[0][COL_ORG_NAME]) 
                        ? orgRecords[0][COL_ORG_NAME] 
                        : "Organization Name";
        
        // Update Header
        const headerEl = document.querySelector('h2 .line1');
        if (headerEl) headerEl.textContent = orgName;


        // Process Account Types
        const typeRecords = convertToRecords(typeData);
        typeRecords.forEach(rec => {
          accountTypesMap[rec.id] = rec[COL_TYPE_NAME];
        });

        // Process Accounts
        const accRecords = convertToRecords(accData);
        accRecords.forEach(rec => {
          accountsMap[rec.id] = rec;
          if (rec[COL_ACC_ACCOUNT_ID]) {
            accountsByIdMap[rec[COL_ACC_ACCOUNT_ID]] = rec;
          }
        });

        // Process Transactions
        const transRecords = convertToRecords(transData);
        
        // Map transactions to the format expected by the widget
        const mappedRecords = transRecords.map(t => {
          // Resolve Account
          // t[COL_TRANS_ACCOUNT_REF] is the Row ID in Accounts table
          const accRef = t[COL_TRANS_ACCOUNT_REF];
          if (!accRef) return null; // Uncategorized

          const account = accountsMap[accRef]; 
          if (!account) return null; // Invalid reference

          // Resolve Account Type
          const typeRef = account[COL_ACC_TYPE_REF];
          const typeName = accountTypesMap[typeRef];

          if (!typeName) return null; // No type (e.g. Asset/Liability maybe? Or just missing)

          // Resolve Hierarchy
          const hierarchy = getAccountHierarchy(account);

          // Resolve Date
          // Prefer Change_Date_Posted (stored), fallback to Date_Cleared (formula/stored)
          // Dates are seconds since epoch
          let dateVal = t[COL_TRANS_DATE_POSTED];
          if (!dateVal && dateVal !== 0) { // Check for null/undefined/empty
             dateVal = t[COL_TRANS_DATE_CLEARED];
          }

          return {
             Amount: t[COL_TRANS_AMOUNT],
             Account_Type_Name: typeName,
             Account: account[COL_ACC_NAME],
             Transaction_Date: dateVal, // Keep as raw value (seconds), format later
             Accounts_1: hierarchy[0] || null,
             Accounts_2: hierarchy[1] || null,
             Accounts_3: hierarchy[2] || null,
             Accounts_4: hierarchy[3] || null
          };
        }).filter(r => r !== null); // Remove invalid records

        console.log(`Loaded ${mappedRecords.length} valid records out of ${transRecords.length} total.`);
        
        if (mappedRecords.length > 0) {
            console.log("Sample mapped record:", mappedRecords[0]);
        }

        processRecords(mappedRecords);

      } catch (err) {
        console.error("Error loading data:", err);
        errorMessage.innerText = "Error loading data. Check console.";
      }
    }

    // Helper to traverse account hierarchy
    function getAccountHierarchy(account) {
      const path = [];
      let current = account;
      
      // Safety limit to prevent infinite loops
      let depth = 0;
      while (current && depth < 10) {
        path.unshift(current[COL_ACC_NAME]); // Add to front
        
        // Move to parent
        // PARENT_ACCOUNT column stores the ACCOUNT_ID of the parent
        const parentId = current[COL_ACC_PARENT];
        if (parentId) {
           current = accountsByIdMap[parentId]; // Look up by ACCOUNT_ID
        } else {
           current = null;
        }
        depth++;
      }
      return path;
    }

    // Helper to convert Grist column-oriented data to row-oriented records
    function convertToRecords(data) {
      const columns = Object.keys(data);
      if (columns.length === 0) return [];
      // If data is array of objects (unlikely for fetchTable but check)
      if (Array.isArray(data)) return data;

      // data.id is the array of row IDs
      const numRows = data.id ? data.id.length : 0;
      const records = [];
      for (let i = 0; i < numRows; i++) {
        const record = { id: data.id[i] };
        columns.forEach(col => {
          if (col !== 'id') {
             record[col] = data[col][i];
          }
        });
        records.push(record);
      }
      return records;
    }

    // Main processing function
    function processRecords(records) {
      try {
        const incomeDetails = document.getElementById('income-details');
        const expenseDetails = document.getElementById('expense-details');
        const netProfitDisplay = document.getElementById('net-profit');
        const monthSubtitle = document.getElementById('monthSubtitle');
        const errorMessage = document.getElementById('error-message');

        errorMessage.innerText = '';
        incomeDetails.innerHTML = `<tr><th>Account</th><th>Amount</th></tr>`;
        expenseDetails.innerHTML = `<tr><th>Account</th><th>Amount</th></tr>`;
        netProfitDisplay.innerText = '$0.00';

        // --- Quarter Calculation Logic ---
        const today = new Date();
        const currentMonth = today.getMonth(); // 0-11
        const currentYear = today.getFullYear();

        // Calculate previous quarter
        const currentQuarter = Math.floor(currentMonth / 3) + 1;
        
        let targetQuarter, targetYear;
        if (currentQuarter === 1) {
            targetQuarter = 4;
            targetYear = currentYear - 1;
        } else {
            targetQuarter = currentQuarter - 1;
            targetYear = currentYear;
        }

        const startMonth = (targetQuarter - 1) * 3;
        // Construct Start Date (YYYY-MM-DD) - UTC
        const startDate = new Date(Date.UTC(targetYear, startMonth, 1));
        const endDate = new Date(Date.UTC(targetYear, startMonth + 3, 0)); // Last day of quarter

        const quarterNames = ["Q1", "Q2", "Q3", "Q4"];
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        
        const startMonthName = monthNames[startDate.getUTCMonth()];
        const endMonthName = monthNames[endDate.getUTCMonth()];
        
        if (monthSubtitle) {
          monthSubtitle.textContent = `${quarterNames[targetQuarter - 1]} ${targetYear} (${startMonthName} - ${endMonthName})`;
        }
        
        // Use UTC Timestamps for comparison (seconds)
        // Set explicit boundaries
        const startVal = startDate.getTime() / 1000;
        const endVal = endDate.getTime() / 1000 + 86399; // Include full end day

        console.log("Quarter Calculation:", {
            targetQuarter,
            targetYear,
            startStr: startDate.toISOString().split('T')[0],
            endStr: endDate.toISOString().split('T')[0],
            startVal,
            endVal
        });

        // Filter records
        const filteredRecords = records.filter(record => {
          let val = record.Transaction_Date;
          if (Array.isArray(val)) val = val[1];
          if (!val) return false;
          
          return val >= startVal && val <= endVal;
        });

        if (filteredRecords.length === 0) {
          errorMessage.innerText = `No transactions found for ${quarterNames[targetQuarter - 1]} ${targetYear} (${startMonthName} - ${endMonthName}).`;
          console.log("Zero records matched date filter.");
          return;
        }

        // Separate Income and Expense
        const incomeRecords = [];
        const expenseRecords = [];

        filteredRecords.forEach(record => {
          const type = record.Account_Type_Name;
          if (type && type.trim().toLowerCase() === 'income') {
            incomeRecords.push(record);
          } else if (type && type.trim().toLowerCase() === 'expense') {
            expenseRecords.push(record);
          }
        });

        // Build hierarchies
        const hierarchyIncome = sortHierarchy(buildHierarchy(incomeRecords));
        const hierarchyExpense = sortHierarchy(buildHierarchy(expenseRecords));

        // Display
        insertHierarchyIntoTable(hierarchyIncome, incomeDetails);
        insertHierarchyIntoTable(hierarchyExpense, expenseDetails);

        // Totals
        let totalIncome = calculateTotal(hierarchyIncome);
        let totalExpenses = calculateTotal(hierarchyExpense);

        // Calculate Net Profit
        // Restore original logic: assume Expenses might be negative (if signed DB) or positive.
        // But user's original code used: netProfit = totalIncome + totalExpenses;
        const netProfit = totalIncome + totalExpenses; 
        
        netProfitDisplay.innerText = `$${netProfit.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

        // Add Totals rows
        addTotalRow(incomeDetails, "Total Income", totalIncome);
        // Display Expenses as positive number for readability
        addTotalRow(expenseDetails, "Total Expenses", Math.abs(totalExpenses));

      } catch (err) {
        console.error("Error in processRecords:", err);
        errorMessage.innerText = "Error processing records: " + err.message;
      }
    }

    function calculateTotal(hierarchy) {
        let total = 0;
        Object.values(hierarchy).forEach(node => {
            total += node.amount;
        });
        return total;
    }

    function addTotalRow(table, label, amount) {
        const row = table.insertRow();
        row.classList.add('total-row');
        const labelCell = row.insertCell(0);
        const amountCell = row.insertCell(1);
        labelCell.innerText = label;
        amountCell.innerText = `$${amount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    }

    // Function to build hierarchical account structure
    function buildHierarchy(records) {
      const hierarchy = {};
      records.forEach(record => {
          const amount = parseFloat(record.Amount) || 0;
          // Expenses should be treated as positive magnitude for categorization if they are not already
          // But usually in P&L, you sum them up. We use the raw amount.
          
          const accounts1 = record.Accounts_1 || 'Uncategorized';
          const accounts2 = record.Accounts_2 || '';
          const accounts3 = record.Accounts_3 || '';
          const accounts4 = record.Accounts_4 || '';

          // Initialize hierarchy levels
          if (!hierarchy[accounts1]) {
            hierarchy[accounts1] = { amount: 0, children: {} };
          }
          hierarchy[accounts1].amount += amount;

          if (accounts2) {
            if (!hierarchy[accounts1].children[accounts2]) {
              hierarchy[accounts1].children[accounts2] = { amount: 0, children: {} };
            }
            hierarchy[accounts1].children[accounts2].amount += amount;

            if (accounts3) {
              if (!hierarchy[accounts1].children[accounts2].children[accounts3]) {
                hierarchy[accounts1].children[accounts2].children[accounts3] = { amount: 0, children: {} };
              }
              hierarchy[accounts1].children[accounts2].children[accounts3].amount += amount;

              if (accounts4) {
                if (!hierarchy[accounts1].children[accounts2].children[accounts3].children[accounts4]) {
                  hierarchy[accounts1].children[accounts2].children[accounts3].children[accounts4] = { amount: 0 };
                }
                hierarchy[accounts1].children[accounts2].children[accounts3].children[accounts4].amount += amount;
              }
            }
          }
      });
      return hierarchy;
    }

    // Function to sort a hierarchy alphabetically
    function sortHierarchy(hierarchy) {
      const sorted = {};
      const keys = Object.keys(hierarchy).sort((a, b) => a.localeCompare(b));
      keys.forEach(key => {
        sorted[key] = { ...hierarchy[key] };
        if (sorted[key].children && Object.keys(sorted[key].children).length > 0) {
          sorted[key].children = sortHierarchy(sorted[key].children);
        }
      });
      return sorted;
    }

    // Function to insert hierarchy into table
    function insertHierarchyIntoTable(hierarchy, tableBody, level = 0) {
      const indentClass = `indent-${level}`;
      Object.keys(hierarchy).forEach(account => {
        const row = tableBody.insertRow();
        const accountCell = row.insertCell(0);
        const amountCell = row.insertCell(1);
        accountCell.innerHTML = `<span class="${indentClass}">${account}</span>`;
        amountCell.innerText = `$${hierarchy[account].amount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;

        if (hierarchy[account].children && Object.keys(hierarchy[account].children).length > 0) {
          insertHierarchyIntoTable(hierarchy[account].children, tableBody, Math.min(level + 1, 4));
        }
      });
    }

    // Load data immediately
    loadData();
  </script>
</body>
</html>